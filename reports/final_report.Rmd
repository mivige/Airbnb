---
title: "Airbnb Mallorca Data Analysis"
author: "Angus, Michele, Finn Dicke"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
    theme: united
---

```{r setup, include=FALSE}
# Load required libraries
library(tidyverse)
#library(kableExtra)
library(sf)
library(ggplot2)
library(tmap)
library(stringr)


# Set global chunk options
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.width = 10,
  fig.height = 6
)
```

# Data Loading

En esta sección se realiza la carga de los datos necesarios para el análisis del proyecto. El proceso incluye la lectura de diversos conjuntos de datos, así como la validación básica de la integridad de los mismos.

1. **Carga de Datos:**
   - Se cargan datos de anuncios (`listings_common0_select`) almacenados en un archivo `.RData`, los cuales contienen información clave sobre los anuncios de Airbnb en Mallorca.
   - Se leen las reseñas de los usuarios desde un archivo CSV comprimido (`reviews.csv.gz`), lo cual incluye datos sobre comentarios y fechas asociados a los anuncios.
   - Se importan los datos de municipios desde otro archivo CSV (`neighbourhoods.csv`) y se cargan las geometrías correspondientes a los barrios desde un archivo GeoJSON para su visualización geoespacial.

2. **Validación de Datos:**
   - Se asegura que los datos cargados cumplan con criterios mínimos de calidad, como la existencia de los conjuntos necesarios y la presencia de columnas clave en los datos de anuncios.
   - Se proporciona un resumen básico del número de registros cargados en cada conjunto de datos para garantizar que el proceso de carga se completó correctamente.

Este proceso establece la base para los análisis posteriores, asegurando que los datos sean consistentes, completos y listos para su exploración y modelado.

```{r data_loading}
# Function to load and preprocess data
load_airbnb_data <- function() {
    # Load listings data
    load("../clean_data/mallorca/listing_common0_select.RData")
    ls()

    str(listings_common0_select)

    unique(listings_common0_select$date)
    
    # Read reviews data
    reviews = read_csv("../data/mallorca/2023-12-17/reviews.csv.gz")
    str(reviews)

    head(reviews)
    
    # Read neighbourhoods
    municipios = read_csv("../data/mallorca/2023-12-17/neighbourhoods.csv")
    str(municipios)
    
    head(municipios)

    # Leer el archivo GeoJSON
    geojson_sf <- sf::st_read("../data/mallorca/2024-09-13/neighbourhoods.geojson")

    # Crear un mapa

    # interactivo
    tmap_mode("plot") # Cambiar a modo  view/plot   que es interactivo/estático
    tm_shape(geojson_sf) + tm_polygons(col = "cyan", alpha = 0.6) + tm_layout(title = "Mapa - GeoJSON Mallorca con municipios")

    # Return list of processed datasets
    list(
        listings = listings_common0_select,
        reviews = reviews,
        municipios = municipios
    )
}

# Load and preprocess data
airbnb_data <- load_airbnb_data()

# Data validation
validate_data <- function(data) {
    # Add checks for data integrity
    stopifnot(
        "Listings data is missing" = !is.null(data$listings),
        "Reviews data is missing" = !is.null(data$reviews),
        "Listings have required columns" = all(c("id", "price", "neighbourhood_cleansed", "date") %in% colnames(data$listings))
    )
    
    # Print basic data summary
    print("Data Loading Summary:")
    print(paste("Listings records:", nrow(data$listings)))
    print(paste("Reviews records:", nrow(data$reviews)))
    print(paste("Municipalities:", nrow(data$municipios)))
}

# Validate loaded data
validate_data(airbnb_data)
```

# 01 - Tabla Estadísticos Descriptivos

```{r question_1}
# Cargar librerías necesarias
library(dplyr)
library(kableExtra)

# Paso 1: Preparar los datos
# Convertir las fechas a formato 'Year' y agrupar por municipio y año
data_prepared <- listings_common0_select %>%
  mutate(year = format(date, "%Y")) %>%  # Extraer el año de la columna 'date'
  group_by(neighbourhood_cleansed, year)  # Agrupar por municipio y año

# Paso 2: Calcular estadísticos descriptivos
stats <- data_prepared %>%
  summarise(
    mean_price = mean(price, na.rm = TRUE),       # Media del precio
    median_price = median(price, na.rm = TRUE),  # Mediana del precio
    sd_price = sd(price, na.rm = TRUE),          # Desviación estándar del precio
    mean_reviews = mean(number_of_reviews, na.rm = TRUE),       # Media de reseñas
    median_reviews = median(number_of_reviews, na.rm = TRUE),  # Mediana de reseñas
    sd_reviews = sd(number_of_reviews, na.rm = TRUE)           # Desviación estándar de reseñas
  ) %>%
  ungroup()

stats %>%
  kable("html", caption = "Estadísticos descriptivos por municipio y año") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)
```

# 02 - Normality Assessment

En esta sección se realiza un análisis de normalidad sobre variables clave (`price` y `number_of_reviews`) para dos ubicaciones específicas: **Pollença** y **Palma de Mallorca**. Este análisis incluye la filtración de datos relevantes y la visualización de las distribuciones de las variables seleccionadas.

1. **Filtración de Datos:**
   - Se seleccionan datos correspondientes al **13 de septiembre de 2024**.
   - Se filtran ubicaciones específicas: **Pollença** y **Palma de Mallorca**.
   - Se limita el rango de precios a valores razonables entre 50 y 400 euros, para excluir outliers extremos.

2. **Función para Visualización de Distribuciones:**
   - Se define una función genérica, `plot_distribution`, que permite:
     - Graficar histogramas de frecuencias con densidad de núcleo superpuesta.
     - Añadir una curva de densidad normal utilizando la media y desviación estándar de los datos.
   - Los gráficos permiten comparar las distribuciones empíricas de los datos con una distribución normal teórica.

3. **Análisis y Visualización:**
   - Se generan gráficos separados para cada combinación de variable (`price` y `number_of_reviews`) y ubicación (**Pollença** y **Palma de Mallorca**):
     - **Pollença:**
       - Distribución de precios (`price`).
       - Número de reseñas (`number_of_reviews`).
     - **Palma de Mallorca:**
       - Distribución de precios (`price`).
       - Número de reseñas (`number_of_reviews`).
   - Cada gráfico incluye:
     - Histograma con densidad empírica.
     - Densidad de núcleo en rojo.
     - Curva de densidad normal en azul (línea discontinua).

4. **Conclusiones Visuales:**
   - Estos gráficos permiten evaluar visualmente si las distribuciones de las variables clave se aproximan a una distribución normal, lo cual es relevante para determinar los métodos estadísticos aplicables en análisis posteriores.

Este análisis es una etapa crucial para comprender la naturaleza de los datos y elegir enfoques estadísticos adecuados para las siguientes fases del proyecto.

```{r normality_assessment}
# Filter data for the specified date and locations
data_filtered <- airbnb_data$listings %>%
  filter(
    date == as.Date("2024-09-13"),
    neighbourhood_cleansed %in% c("Pollença", "Palma de Mallorca"),
    price > 50 & price < 400 # Filter for valid price range
  )

# Function to plot distribution with histogram, kernel density, and normal density
plot_distribution <- function(data, variable, location) {
  # Extract the data for the given variable and location
  data_subset <- data %>% filter(neighbourhood_cleansed == location)
  values <- data_subset[[variable]]

  # Calculate mean and standard deviation
  mean_val <- mean(values, na.rm = TRUE)
  sd_val <- sd(values, na.rm = TRUE)

  # Create the plot
  ggplot(data_subset, aes_string(x = variable)) +
    geom_histogram(aes(y = ..density..), bins = 30, fill = "skyblue", alpha = 0.6) +
    geom_density(color = "red", size = 1) +
    stat_function(fun = dnorm, args = list(mean = mean_val, sd = sd_val), color = "blue", linetype = "dashed", size = 1) +
    labs(
      title = paste("Distribution of", variable, "in", location),
      x = variable,
      y = "Density"
    ) +
    theme_minimal()
}

# Plot for `price` in Pollença
plot_price_pollenca <- plot_distribution(data_filtered, "price", "Pollença")

# Plot for `price` in Palma
plot_price_palma <- plot_distribution(data_filtered, "price", "Palma de Mallorca")

# Plot for `number_of_reviews` in Pollença
plot_reviews_pollenca <- plot_distribution(data_filtered, "number_of_reviews", "Pollença")

# Plot for `number_of_reviews` in Palma
plot_reviews_palma <- plot_distribution(data_filtered, "number_of_reviews", "Palma de Mallorca")

# Display the plots
print(plot_price_pollenca)
print(plot_price_palma)
print(plot_reviews_pollenca)
print(plot_reviews_palma)

```

# 03 - 

```{r question_3}

```

# 04 - 

```{r question_4}

```

# 05 - Proporción e Intervalo de Confianza 2024

En esta sección se analiza la proporción de apartamentos con una valoración promedio (review_scores_rating) mayor que 4 en los municipios Palma de Mallorca y Pollença durante el periodo "2024-03-23". Este análisis examina las diferencias en las proporciones entre ambos municipios y construye un intervalo de confianza para determinar si estas diferencias son estadísticamente significativas.

1. **Extracción de Datos:**
   -Se filtran los anncios correspondientes a los municipos de **Palma de Mallorca** y **Pollença** para el periodo "2024-03-23".
   -Se selecciona la columna (`review_scores_rating`) eliminando valores inexistentes (**Na**) con `na.omit`.
   -Los datos resultantes se agrupan por municipio, permitiendo realizar cálculos independientes para cada uno.

2. **Cálculo de Proporciones:**
   - Se calcula la porporción de apartamentos con `review_scores_rating > 4` en cada municipio:
      -**Proporción(p)**: número de apartamentos con `review_scores_rating > 4` dividido por el tamaño            total de la muestra.
   - Tambiéns e calcula el tamaño de la muestra (n) para cada municipio.

3. **Diferencias Proporcionales:**
  - Se calcula la diferencia entre las proporciones de ambos municipios:
    Diferencia= p_pollença - p_palma
   

4. **Intervalo de confianza:**
   - Se calcula el error estándar para la diferencia de proporciones utilizando la fórmula: 
   
    $$ \text{Error estándar} = \sqrt{\frac{p_{\text{Pollença}}(1 - p_{\text{Pollença}})}{n_{\text{Pollença}}} + \frac{p_{\text{Palma}}(1 - p_{\text{Palma}})}{n_{\text{Palma}}}}$$
    
  -Se consruye un intervalo de confianza al 95%:
      $$IC = Diferencia \pm z* ErrorEstándar$$

```{r question_5}
# Filtrar los datos para el periodo "2024-03-23" y los municipios deseados
rating_Pollenca= listings_common0_select %>%
  filter(neighbourhood_cleansed=="Pollença" & date=="2024-03-23")
rating_Pollenca=na.omit(rating_Pollenca$review_scores_rating)

rating_Palma= listings_common0_select %>%
  filter(neighbourhood_cleansed=="Palma de Mallorca" & date=="2024-03-23")
rating_Palma=na.omit(rating_Palma$review_scores_rating)

# Calcular la proporción de apartamentos con 'review_scores_rating' > 4 por municipio

#Pollenca
p_Pollenca=mean(rating_Pollenca>4)
n_Pollenca=length(rating_Pollenca)
p_Pollenca
n_Pollenca

#Mallorca
p_Mallorca=mean(rating_Palma>4)
n_Mallorca=length(rating_Palma)
p_Mallorca
n_Mallorca

# Calcular la diferencia de proporciones
diferencia <- p_Pollenca - p_Mallorca

# Calcular el error estándar
error <- sqrt((p_Pollenca * (1 - p_Pollenca) / n_Pollenca) + (p_Mallorca * (1 - p_Mallorca) / n_Mallorca))

# Valor crítico para un intervalo de confianza del 95%
z <- qnorm(0.975)

# Intervalo de confianza
intervalo <- c(diferencia - z * error, diferencia + z * error)

# Resultados finales
list(
  Diferencia = diferencia,
  IC_95 = intervalo,
  Palma_Proporción = p_Mallorca,
  Pollença_Proporción = p_Pollenca
)
```

5. **Conclusión:**
  -Proporciones observadas: la proporción de apartamentos es mayor en **Palma de Mallorca** que en **Pollença**
  -Este resultado sugiere que los apartamentos en **Palma de Mallorca** tienen una valoración promedio significativamente mejor que los de **Pollença**, lo que podría reflejar diferencias en la calidad de los servicios o en las experiencias de los huéspedes.

# 06 - Proporción e Intervalo de Confianza 2023 y 2024

```{r question_6}
library(dplyr)

# Filtrar y combinar datos para Palma de Mallorca
rating_2023M <- listings_common0_select %>%
  filter(neighbourhood_cleansed == "Palma de Mallorca" & date == "2023-12-17") %>%
  arrange(id) %>%
  select(id, review_scores_rating)

rating_2024M <- listings_common0_select %>%
  filter(neighbourhood_cleansed == "Palma de Mallorca" & date == "2024-03-23") %>%
  arrange(id) %>%
  select(id, review_scores_rating)

rating_23_24_M <- rating_2023M %>%
  left_join(rating_2024M, by = "id", suffix = c("_2023", "_2024"))

# Filtrar y combinar datos para Pollença
rating_2023P <- listings_common0_select %>%
  filter(neighbourhood_cleansed == "Pollença" & date == "2023-12-17") %>%
  arrange(id) %>%
  select(id, review_scores_rating)

rating_2024P <- listings_common0_select %>%
  filter(neighbourhood_cleansed == "Pollença" & date == "2024-03-23") %>%
  arrange(id) %>%
  select(id, review_scores_rating)

rating_23_24_P <- rating_2023P %>%
  left_join(rating_2024P, by = "id", suffix = c("_2023", "_2024"))

# Calcular proporciones para Pollença
p_Pollenca <- mean(rating_23_24_P$review_scores_rating_2023 > 4, na.rm = TRUE)
n_Pollenca <- sum(!is.na(rating_23_24_P$review_scores_rating_2023))

# Calcular proporciones para Palma de Mallorca
p_Mallorca <- mean(rating_23_24_M$review_scores_rating_2023 > 4, na.rm = TRUE)
n_Mallorca <- sum(!is.na(rating_23_24_M$review_scores_rating_2023))

# Calcular diferencia de proporciones
diferencia <- p_Pollenca - p_Mallorca

# Calcular el error estándar
error <- sqrt((p_Pollenca * (1 - p_Pollenca) / n_Pollenca) +
                (p_Mallorca * (1 - p_Mallorca) / n_Mallorca))

# Valor crítico para un intervalo de confianza del 95%
z <- qnorm(0.975)

# Calcular intervalo de confianza
intervalo <- c(diferencia - z * error, diferencia + z * error)

# Resultados finales
list(
  Diferencia = diferencia,
  IC_95 = intervalo,
  Palma_Proporción = p_Mallorca,
  Pollença_Proporción = p_Pollenca
)
```

# 07 - Zipf's Law

En esta sección se analiza la Ley de Zipf aplicada a los comentarios de reseñas en **Palma de Mallorca**. Este análisis examina la relación entre la frecuencia de longitudes de comentarios y su rango, incluyendo transformaciones logarítmicas para verificar el cumplimiento de esta ley en el conjunto de datos.

1. **Extracción de Datos:**
   - Se filtran los **anuncios** correspondientes a **Palma de Mallorca** para obtener sus identificadores (`id`).
   - Se seleccionan únicamente las reseñas asociadas a estos anuncios.
   - Se calcula la longitud de cada comentario en palabras utilizando la función `str_count`.

2. **Cálculo de Frecuencias:**
   - Se determina la frecuencia de cada longitud de comentario y se organiza en orden descendente de frecuencia.
   - Se añaden las siguientes columnas:
     - **Rank:** Posición de cada longitud de comentario en función de su frecuencia, con mayor frecuencia asignada al rango más alto.
     - **Log(Frequency):** Transformación logarítmica de la frecuencia.
     - **Log(Rank):** Transformación logarítmica del rango.
   - Se filtran los datos para analizar rangos entre 10 y 1000, excluyendo outliers extremos.

3. **Regresiones Lineales:**
   - Se realizan tres regresiones lineales para explorar la relación entre frecuencia y rango:
     - Frecuencia (`frequency`) vs. Rango (`rank`).
     - Frecuencia (`frequency`) vs. Logaritmo del rango (`log(rank)`).
     - Logaritmo de la frecuencia (`log(frequency)`) vs. Logaritmo del rango (`log(rank)`) — Esta es la más relevante para evaluar la Ley de Zipf.
   - Se presentan los resúmenes de cada modelo, incluyendo coeficientes y métricas de ajuste.

4. **Visualización de Resultados:**
   - Se generan tres gráficos para interpretar los datos y las relaciones lineales:
     - **Frecuencia vs. Rango:** Puntos de datos con línea de regresión.
     - **Frecuencia vs. Log(Rango):** Visualización semi-logarítmica.
     - **Log(Frecuencia) vs. Log(Rango):** Gráfico log-log, principal para la Ley de Zipf.
   - Cada gráfico incluye puntos de datos y líneas de ajuste generadas por los modelos de regresión lineal.

5. **Conclusión:**
   - Este análisis permite evaluar si las longitudes de comentarios de reseñas en Palma de Mallorca siguen un patrón consistente con la Ley de Zipf.
   - Los gráficos log-log y los resultados de regresión proporcionan evidencia visual y estadística sobre esta relación.

El cumplimiento de la Ley de Zipf puede ser indicativo de patrones universales en los datos textuales, relevantes para estudios de lingüística, comportamiento y análisis de datos. Este análisis constituye una parte integral de la comprensión de las características subyacentes del conjunto de datos.

```{r Zipfs_law}
# Save all the listings in Palma
palma_listing_ids <- airbnb_data$listings %>%
  filter(neighbourhood_cleansed == "Palma de Mallorca") %>%
  pull(id)  # Extract as a vector

# Extract only the reviews for Palma
palma_reviews <- airbnb_data$reviews %>%
  filter(as.character(listing_id) %in% as.character(palma_listing_ids))

# Calculate the length of each comment in words
palma_reviews <- palma_reviews %>% 
  mutate(comment_length = str_count(comments, "\\w+"))

# Compute the frequency of each comment length
length_freq <- palma_reviews %>% 
  count(comment_length, name = "frequency") %>% 
  arrange(desc(frequency))

# Add rank and log transformations for Zipf's analysis
length_freq <- length_freq %>% 
  mutate(
    rank = rank(-frequency, ties.method = "first"), # Rank by descending frequency
    log_frequency = log(frequency),
    log_rank = log(rank)
  ) %>% 
  filter(rank > 10 & rank < 1000) # Filter for specific rank range

# Perform linear regressions
# Regression of frequency vs. rank
model_freq_rank <- lm(frequency ~ rank, data = length_freq)
summary(model_freq_rank)

# Regression of frequency vs. log(rank)
model_freq_logrank <- lm(frequency ~ log_rank, data = length_freq)
summary(model_freq_logrank)

# Regression of log(frequency) vs. log(rank) - most relevant for Zipf's law
model_logfreq_logrank <- lm(log_frequency ~ log_rank, data = length_freq)
summary(model_logfreq_logrank)

# Plot the results
# Frequency vs Rank
ggplot(length_freq, aes(x = rank, y = frequency)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", se = TRUE, color = "red") +
  labs(
    title = "Frequency vs Rank",
    x = "Rank",
    y = "Frequency"
  ) +
  theme_minimal()

# Frequency vs Log(Rank)
ggplot(length_freq, aes(x = log_rank, y = frequency)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", se = TRUE, color = "blue") +
  labs(
    title = "Frequency vs Log(Rank)",
    x = "Log(Rank)",
    y = "Frequency"
  ) +
  theme_minimal()

# Log(Frequency) vs Log(Rank)
ggplot(length_freq, aes(x = log_rank, y = log_frequency)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", se = TRUE, color = "green") +
  labs(
    title = "Log(Frequency) vs Log(Rank)",
    x = "Log(Rank)",
    y = "Log(Frequency)"
  ) +
  theme_minimal()
```